{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import MersenneTwister from \"mersenne-twister\";\n\ninterface Coordinates {\n  latitude: number;\n  longitude: number;\n}\n\n/**\n * Given POI A with a latitude and longitude, generate POI B with a random latitude & longitude within min & max distance\n *\n * @param {number} latitude         Latitude\n * @param {number} longitude        Longitude\n * @param {number} minDistance      Minimum distance of POI from given coordinates (in metres)\n * @param {number} maxDistance      Maximum distance of POI from given coordinates (in metres)\n * @returns {object}                New, random coordinates (latitude & longitude)\n */\nfunction getLocationAwayFromPOI(\n  latitude: number,\n  longitude: number,\n  minDistance: number,\n  maxDistance: number\n): Coordinates {\n  // random_excl() helps to ensure ∀x∊(0, 1)\n  const { random_excl } = new MersenneTwister();\n  const { PI, cos, acos, sqrt, min, max, floor } = Math;\n\n  // Equatorial and polar radii extrema\n  const earthPolarRadius = 6356.7523;\n  const earthEquatorialRadius = 6378.137;\n\n  // Convert metres to km\n  minDistance = max(minDistance || 0, 1) / 1000;\n  maxDistance = max(maxDistance || 0, 1) / 1000;\n\n  // Degrees to rad\n  const latitudeRad = latitude * (PI / 180);\n  const longitudeRad = longitude * (PI / 180);\n\n  // Constraints: minDistance < distance < maxDistance\n  const md = minDistance ** 2;\n  const distance = min(\n    maxDistance,\n    sqrt(random_excl() * (maxDistance ** 2 - md) + md)\n  );\n\n  // Use Haversine Formula so given [lat1, lon1], we need to find new [lat2, lon2]\n\n  let newLatitude = cos(random_excl() * PI) * (distance / earthPolarRadius);\n\n  let newLongitude =\n    (cos(distance / earthEquatorialRadius) - cos(newLatitude)) /\n      (cos(latitudeRad) * cos(newLatitude - latitudeRad)) +\n    1;\n\n  // Ensure that ∀x∊[-1, 1]\n  newLongitude = acos(max(-1, min(1, newLongitude)));\n\n  // Use simple randomness: -1 ∨ 1 so to either add or subtract from given coordinates\n  const posNegLatitude = floor(random_excl() * 2) ? -1 : 1;\n  const posNegLongitude = floor(random_excl() * 2) ? -1 : 1;\n\n  newLatitude *= posNegLatitude;\n  newLongitude *= posNegLongitude;\n\n  // Prev + delta convert rads to degress\n  newLatitude = (latitudeRad + newLatitude) * (180 / PI);\n  newLongitude = (longitudeRad + newLongitude) * (180 / PI);\n\n  return {\n    latitude: newLatitude,\n    longitude: newLongitude,\n  };\n}\n\nexport { getLocationAwayFromPOI };\n"],"mappings":"AAAA,OAAOA,MAAqB,mBAgB5B,SAASC,EACPC,EACAC,EACAC,EACAC,EACa,CAEb,GAAM,CAAE,YAAAC,CAAY,EAAI,IAAIN,EACtB,CAAE,GAAAO,EAAI,IAAAC,EAAK,KAAAC,EAAM,KAAAC,EAAM,IAAAC,EAAK,IAAAC,EAAK,MAAAC,CAAM,EAAI,KAG3CC,EAAmB,UACnBC,EAAwB,SAG9BX,EAAcQ,EAAIR,GAAe,EAAG,CAAC,EAAI,IACzCC,EAAcO,EAAIP,GAAe,EAAG,CAAC,EAAI,IAGzC,IAAMW,EAAcd,GAAYK,EAAK,KAC/BU,EAAed,GAAaI,EAAK,KAGjCW,EAAKd,GAAe,EACpBe,EAAWR,EACfN,EACAK,EAAKJ,EAAY,GAAKD,GAAe,EAAIa,GAAMA,CAAE,CACnD,EAIIE,EAAcZ,EAAIF,EAAY,EAAIC,CAAE,GAAKY,EAAWL,GAEpDO,GACDb,EAAIW,EAAWJ,CAAqB,EAAIP,EAAIY,CAAW,IACrDZ,EAAIQ,CAAW,EAAIR,EAAIY,EAAcJ,CAAW,GACnD,EAGFK,EAAeZ,EAAKG,EAAI,GAAID,EAAI,EAAGU,CAAY,CAAC,CAAC,EAGjD,IAAMC,EAAiBT,EAAMP,EAAY,EAAI,CAAC,EAAI,GAAK,EACjDiB,EAAkBV,EAAMP,EAAY,EAAI,CAAC,EAAI,GAAK,EAExD,OAAAc,GAAeE,EACfD,GAAgBE,EAGhBH,GAAeJ,EAAcI,IAAgB,IAAMb,GACnDc,GAAgBJ,EAAeI,IAAiB,IAAMd,GAE/C,CACL,SAAUa,EACV,UAAWC,CACb,CACF","names":["MersenneTwister","getLocationAwayFromPOI","latitude","longitude","minDistance","maxDistance","random_excl","PI","cos","acos","sqrt","min","max","floor","earthPolarRadius","earthEquatorialRadius","latitudeRad","longitudeRad","md","distance","newLatitude","newLongitude","posNegLatitude","posNegLongitude"]}